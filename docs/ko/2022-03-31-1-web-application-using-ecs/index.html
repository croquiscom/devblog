<!DOCTYPE html>
<html lang='ko'>

<head>
  <meta charset='utf-8'>

  <title>ECS를 사용해서 어플리케이션 서비스 하기</title>
  
  <meta name='author' content='kakaostyle.com'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>

  <meta property='og:title' content='ECS를 사용해서 어플리케이션 서비스 하기' />
  <meta property='og:description' content='카카오스타일에서는 한동한 ECS를 사용해서 어플리케이션을 서비스했습니다. 현재는 EKS로 전환하고 있지만, ECS가 상대적으로 단순하기 때문에 서비스 구축 개념을 익히는데 좋은 것 같습니다. (간단한 서비스는 굳이 쿠버네티스를 쓸 필요가 없다고 생각합니다) 그런 의미에서 이번 글에서는 ECS를 이용해 단순한 서비스를 오픈하는 과정을 단계별로 설명해보려고 합니다.' />
  <meta property='og:type' content='article' />
  <meta property='og:url' content='https://devblog.kakaostyle.com/ko/2022-03-31-1-web-application-using-ecs/' />
  
  <meta property='og:image' content='https://devblog.kakaostyle.com/img/og-image.png' />  
  

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css"
    integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link href='/css/style.css?body=1' rel='stylesheet' type='text/css' media='all'>
  <link href='/css/syntax.css?body=1' rel='stylesheet' type='text/css' media='all'>
</head>

<body>
<div class='hp-navbar-top'>
  <div class='container'>
    <div class='row'>
      <div class='col-12'>
        <nav class='hp-nav'>
          <span>
            <a href='/' class='logo-a-tag'>
              <img class='hp-navbar-logo' src='/img/logo-kakaostyle.png'>
              <span class='hp-navbar-logo-font'>기술 블로그</span>
            </a>
          </span>
        </nav>
        <div class='float-right hp-navbar-top-link'>
          <a class='hp-nav-item' href='https://kakaostyle.com' target='_blank'>
            <img class='icon' src='/img/kakaostyle-icon.png'>
          </a>
          <a class='hp-nav-item' href='https://github.com/croquiscom' target='_blank'>
            <img class='icon' src='/img/github-icon.svg'>
          </a>
        </div>
      </div>
    </div>
  </div>
</div>
<div class='hp-navbar'>
  <div class='hp-navbar-bgcolor'>
    <div class='container'>
      <div class='text-center'>
        <div class='hp-navbar-title'>ECS를 사용해서 어플리케이션 서비스 하기</div>
      </div>
    </div>
  </div>
</div>


<div class='container'>

  <div class='row'>
    <div class='col-12'>
      <div class='post-header'>
        <div class='post-tags'>
          

<ul class='tag_box inline'>
  <li><i class='fas fa-tags'></i></li>
  
  <li>
    <a href='/ko/tags/aws'>
      AWS
      <span>7</span>
    </a>
  </li>
  
  <li>
    <a href='/ko/tags/tutorial'>
      Tutorial
      <span>3</span>
    </a>
  </li>
  
</ul>

        </div>
        <div class='float-right'>
          
          <div class='post-author'>
            <i class='fas fa-pencil-alt'></i>
            <span>Simon(윤상민)</span>
          </div>
          
          <div class='post-date'>
            <i class='fas fa-calendar-alt'></i>
            <span>31 March 2022</span>
          </div>
        </div>
      </div>
    </div>

    <div class='col-12 col-lg-9'>
      <p>카카오스타일에서는 한동한 ECS를 사용해서 어플리케이션을 서비스했습니다. 현재는 EKS로 전환하고 있지만, ECS가 상대적으로 단순하기 때문에 서비스 구축 개념을 익히는데 좋은 것 같습니다. (간단한 서비스는 굳이 쿠버네티스를 쓸 필요가 없다고 생각합니다) 그런 의미에서 이번 글에서는 ECS를 이용해 단순한 서비스를 오픈하는 과정을 단계별로 설명해보려고 합니다.</p>
<h2 id="docker-도입-과정">Docker 도입 과정</h2>
<p><a href="https://www.docker.com/">도커</a>에 대한 얘기는 2014~2015년 무렵 들려오기 시작했던 것 같습니다. 혁신적인 솔루션이라는 얘기가 오가고 있었지만, 카카오스타일에서는 <a href="https://aws.amazon.com/ko/elasticbeanstalk/">AWS Elastic Beanstalk</a>를 거쳐, 독자적인 배포 시스템을 갖추고 있었기 때문에 도커의 이득에 대해서 크게 와 닿지 않아 도커로 넘어가는게 상대적으로 늦었던 것 같습니다.</p>
<p>그러던 와중에 처음 필요성을 느꼈던 것은 로컬 개발환경을 갖추는 부분이였던 것 같습니다. 유닛 테스트등을 위해서 로컬에 DB 프로세스 구동이 필요했습니다. 신규 직원에게 <a href="https://brew.sh/">brew</a>로 설치하는 것을 가이드하고 있었는데, <a href="https://docs.docker.com/compose/">Docker Compose</a>로 구성해두었더니 도커에 익숙한 사람은 쉽게 개발 환경을 갖출 수 있었습니다.</p>
<p><img src="/img/content/2022-03-31-1/2022-03-31-1-01.png" alt="2022-03-31-1-01.png"></p>
<p>이후 지토가 하나의 마이크로서비스에 대해서 <a href="https://aws.amazon.com/ko/ecs/">ECS</a> 셋업을 했는데, 세팅된 것을 보고 나니 유용성이 느껴진 것 같습니다. 그래서 빠르게 이후에 빠르게 ECS 전환을 했습니다.</p>
<p><img src="/img/content/2022-03-31-1/2022-03-31-1-02.png" alt="2022-03-31-1-02.png"></p>
<p>ECS 전환전보다 배포 시간이 늘어나긴 했습니다. (이전에는 이미 존재하는 EC2 인스턴스에 새로운 소스를 전송한 후 프로세스만 새로 띄우면 됐습니다) 하지만 점점 마이크로서비스로 나눠지고, 트래픽이 늘어나는 상황에 대응하기에는 ECS가 훨씬 수월했습니다.</p>
<h2 id="docker로-서비스-만들기">Docker로 서비스 만들기</h2>
<p>도커로 구동할 Node.js 어플리케이션을 만들어봅시다. HTTP 요청에 보낸 온 데이터를 그대로 반환하는 간단한 서버입니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// echo.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">req</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</span></span></code></pre></div><p>이 서버를 도커 이미지로 만들기 위해 다음과 같이 Dockerfile을 만들면 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-docker" data-lang="docker"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> node:16</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /opt/app</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> echo.js .<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 3000</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;node&#34;</span><span class="p">,</span> <span class="s2">&#34;echo.js&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p><a href="https://docs.docker.com/engine/reference/commandline/build/">docker build</a>로 도커 이미지를 만들 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build . -t simon-sample
</span></span></code></pre></div><blockquote>
<p>Apple Silicon을 사용한 컴퓨터에서는 platform을 지정해 빌드해야 ECS에서 정상동작합니다. <code>docker build . -t simon-sample --platform=linux/amd64</code></p></blockquote>
<p><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a>을 이용해 이미지로 부터 프로세스를 실행할 수 있습니다. 외부에서 서버에 접근하기 위해 3000번 포트를 열어야 하고, 데몬 모드로 실행합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -p <span class="m">3000</span> -d simon-sample
</span></span></code></pre></div><p><a href="https://curl.se/">curl</a>을 사용해 잘 동작하는지 확인 가능합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl http://localhost:3000 --data <span class="s1">&#39;hello world&#39;</span>    
</span></span><span class="line"><span class="cl">hello world
</span></span></code></pre></div><p>이렇게 만들어진 이미지는 어떠한 환경에서든 동일하게 동작하고, 배포도 단순해집니다.</p>
<h2 id="vpc-셋업">VPC 셋업</h2>
<p>ECS 클러스터 생성에 앞서, 클러스터가 놓일 VPC를 만듭니다.</p>
<p>우리가 원하는 서비스 구조를 위해서는 VPC에 최소한 다음과 같은 것들이 필요합니다. (<a href="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Scenario2.html">퍼블릭 및 프라이빗 서브넷이 있는 VPC(NAT) 문서</a>에서 설명하는 구조와 같습니다.)</p>
<ul>
<li>VPC</li>
<li>인터넷에 노출되는 서버가 놓일 퍼플릭 서브넷 (최소 두개 이상의 AZ)</li>
<li>안전하게 외부로 부터 접근을 차단된, 실제 서비스가 배치될 프라이빗 서브넷 (최소 두개 이상의 AZ)</li>
<li>퍼플릭 서브넷에서 외부 통신을 할 때 사용하는 인터넷 게이트웨이</li>
<li>프라이빗 서브넷에서 외부 통신이 필요할 때(아웃바운드 전용) 사용하는 NAT 게이트웨이</li>
<li>퍼플릭 서브넷에 연결할 라우팅 테이블. 서브넷에서 다른 서브넷에 접근할 때 규칙과, 외부(0.0.0.0/0)에 접근할 때의 규칙(인터넷 게이트웨이를 거치게 함)을 정의합니다.</li>
<li>프라이빗 서브넷에 연결할 라우팅 테이블. 퍼플릭 라우팅 테이블과 비슷한 규칙이지만, 외부에 접근시 NAT 게이트웨이를 거칩니다.</li>
</ul>
<p><img src="/img/content/2022-03-31-1/2022-03-31-1-03.png" alt="Sample VPC"></p>
<p>카카오스타일은 인프라 정의시 <a href="https://www.terraform.io/">Terraform</a>을 사용합니다. 여기서는 세부 사항을 이해하기 위해 개별 리소스를 정의하고 있지만, <a href="https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest">terraform-aws-modules/vpc/aws</a> 같은 모듈을 써서 편하게 정의하는 것도 가능합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="k">provider</span> <span class="s2">&#34;aws&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  region</span> <span class="o">=</span> <span class="s2">&#34;ap-northeast-2&#34;</span>
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">locals</span> {
</span></span><span class="line"><span class="cl"><span class="n">  vpc_name</span>        <span class="o">=</span> <span class="s2">&#34;simon-test&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  cidr</span>            <span class="o">=</span> <span class="s2">&#34;10.194.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  public_subnets</span>  <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;10.194.0.0/24&#34;, &#34;10.194.1.0/24&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  private_subnets</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;10.194.100.0/24&#34;, &#34;10.194.101.0/24&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  azs</span>             <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;ap-northeast-2a&#34;, &#34;ap-northeast-2c&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## VPC를 생성합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_vpc&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  cidr_block</span> <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">cidr</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>       <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">vpc_name</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## VPC 생성시 기본으로 생성되는 라우트 테이블에 이름을 붙입니다
</span></span></span><span class="line"><span class="cl"><span class="c1">## 이걸 서브넷에 연결해 써도 되지만, 여기서는 사용하지 않습니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_default_route_table&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  default_route_table_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">default_route_table_id</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>                   <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-default&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## VPC 생성시 기본으로 생성되는 보안 그룹에 이름을 붙입니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_default_security_group&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>   <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-default&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 퍼플릭 서브넷에 연결할 인터넷 게이트웨이를 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_internet_gateway&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>   <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-igw&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 퍼플릭 서브넷에 적용할 라우팅 테이블
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_route_table&#34; &#34;public&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>   <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-public&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 퍼플릭 서브넷에서 인터넷에 트래픽 요청시 앞서 정의한 인터넷 게이트웨이로 보냅니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_route&#34; &#34;public_worldwide&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  route_table_id</span>         <span class="o">=</span> <span class="k">aws_route_table</span><span class="p">.</span><span class="k">public</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  destination_cidr_block</span> <span class="o">=</span> <span class="s2">&#34;0.0.0.0/0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  gateway_id</span>             <span class="o">=</span> <span class="k">aws_internet_gateway</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 퍼플릭 서브넷을 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_subnet&#34; &#34;public&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  count</span> <span class="o">=</span> <span class="k">length</span><span class="p">(</span><span class="k">local</span><span class="p">.</span><span class="k">public_subnets</span><span class="p">)</span><span class="c1"> # 여러개를 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span>                  <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  cidr_block</span>              <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">public_subnets</span><span class="p">[</span><span class="k">count</span><span class="p">.</span><span class="k">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  availability_zone</span>       <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">azs</span><span class="p">[</span><span class="k">count</span><span class="p">.</span><span class="k">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  map_public_ip_on_launch</span> <span class="o">=</span> <span class="kt">true</span><span class="c1"> # 퍼플릭 서브넷에 배치되는 서비스는 자동으로 공개 IP를 부여합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">  tags</span>                    <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-public-${count.index + 1}&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 퍼플릭 서브넷을 라우팅 테이블에 연결합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_route_table_association&#34; &#34;public&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  count</span> <span class="o">=</span> <span class="k">length</span><span class="p">(</span><span class="k">local</span><span class="p">.</span><span class="k">public_subnets</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">  subnet_id</span>      <span class="o">=</span> <span class="k">aws_subnet</span><span class="p">.</span><span class="k">public</span><span class="p">[</span><span class="k">count</span><span class="p">.</span><span class="k">index</span><span class="p">].</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  route_table_id</span> <span class="o">=</span> <span class="k">aws_route_table</span><span class="p">.</span><span class="k">public</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## NAT 게이트웨이는 고정 IP를 필요로 합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_eip&#34; &#34;nat_gateway&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  vpc</span>  <span class="o">=</span> <span class="kt">true</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span> <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-natgw&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 프라이빗 서브넷에서 인터넷 접속시 사용할 NAT 게이트웨이
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_nat_gateway&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  allocation_id</span> <span class="o">=</span> <span class="k">aws_eip</span><span class="p">.</span><span class="k">nat_gateway</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  subnet_id</span>     <span class="o">=</span> <span class="k">aws_subnet</span><span class="p">.</span><span class="k">public</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="k">id</span><span class="c1"> # NAT 게이트웨이 자체는 퍼플릭 서브넷에 위치해야 합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">  tags</span>          <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-natgw&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 프라이빗 서브넷에 적용할 라우팅 테이블
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_route_table&#34; &#34;private&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>   <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-private&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 프라이빗 서브넷에서 인터넷에 트래픽 요청시 앞서 정의한 NAT 게이트웨이로 보냅니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_route&#34; &#34;private_worldwide&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  route_table_id</span>         <span class="o">=</span> <span class="k">aws_route_table</span><span class="p">.</span><span class="k">private</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  destination_cidr_block</span> <span class="o">=</span> <span class="s2">&#34;0.0.0.0/0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  nat_gateway_id</span>         <span class="o">=</span> <span class="k">aws_nat_gateway</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 프라이빗 서브넷을 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_subnet&#34; &#34;private&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  count</span> <span class="o">=</span> <span class="k">length</span><span class="p">(</span><span class="k">local</span><span class="p">.</span><span class="k">private_subnets</span><span class="p">)</span><span class="c1"> # 여러개를 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span>            <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  cidr_block</span>        <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">private_subnets</span><span class="p">[</span><span class="k">count</span><span class="p">.</span><span class="k">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  availability_zone</span> <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">azs</span><span class="p">[</span><span class="k">count</span><span class="p">.</span><span class="k">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  tags</span>              <span class="o">=</span><span class="n"> { Name</span> <span class="o">=</span> <span class="s2">&#34;${local.vpc_name}-private-${count.index + 1}&#34;</span> }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 프라이빗 서브넷을 라우팅 테이블에 연결합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_route_table_association&#34; &#34;private&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  count</span> <span class="o">=</span> <span class="k">length</span><span class="p">(</span><span class="k">local</span><span class="p">.</span><span class="k">private_subnets</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">  subnet_id</span>      <span class="o">=</span> <span class="k">aws_subnet</span><span class="p">.</span><span class="k">private</span><span class="p">[</span><span class="k">count</span><span class="p">.</span><span class="k">index</span><span class="p">].</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  route_table_id</span> <span class="o">=</span> <span class="k">aws_route_table</span><span class="p">.</span><span class="k">private</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="ecs-클러스터">ECS 클러스터</h2>
<p>우리 서비스가 동작할 ECS 클러스터가 필요합니다. 도커 컨테이너가 구동될 EC2 인스턴스를 직접 관리한다면 복잡하지만 Fargate를 쓴다면 크게 신경쓸게 없습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="c1">## ECS 클러스터를 생성합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_ecs_cluster&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span> <span class="o">=</span> <span class="s2">&#34;simon-test&#34;</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="서비스-구동">서비스 구동</h2>
<p>이제 우리가 만든 어플리케이션을 ECS 클러스터에 올릴 차례입니다.</p>
<p>우선 도커 이미지를 업로드할 저장소(<a href="https://aws.amazon.com/ko/ecr/">ECR</a>)를 정의합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="k">locals</span> {
</span></span><span class="line"><span class="cl"><span class="n">  app_name</span> <span class="o">=</span> <span class="s2">&#34;simon-sample&#34;</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## simon-sample 앱을 위한 저장소를 만듭니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_ecr_repository&#34; &#34;simon_sample&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span> <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">app_name</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>첫단계에서 만든 도커 이미지를 다음과 같이 업로드할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">## ECR 저장소에 로그인합니다</span>
</span></span><span class="line"><span class="cl">$ aws ecr get-login-password --region ap-northeast-2 <span class="p">|</span> docker login --username AWS --password-stdin &lt;aws-account-id&gt;.dkr.ecr.ap-northeast-2.amazonaws.com
</span></span><span class="line"><span class="cl"><span class="c1">## 앞서 만든 이미지에 ECR 이름을 붙여줍니다</span>
</span></span><span class="line"><span class="cl">$ docker tag simon-sample:latest &lt;aws-account-id&gt;.dkr.ecr.ap-northeast-2.amazonaws.com/simon-sample:latest
</span></span><span class="line"><span class="cl"><span class="c1">## 이미지를 올립니다</span>
</span></span><span class="line"><span class="cl">$ docker push &lt;aws-account-id&gt;.dkr.ecr.ap-northeast-2.amazonaws.com/simon-sample:latest
</span></span></code></pre></div><p>작업 정의를 다음과 같이 정의합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="c1">## 태스크 정의시 AmazonECSTaskExecutionRolePolicy 정책을 포함한
</span></span></span><span class="line"><span class="cl"><span class="c1">## IAM 역할을 실행 역할(execution role)로 설정해줘야 합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_iam_role&#34; &#34;execution&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span> <span class="o">=</span> <span class="s2">&#34;${local.app_name}-exec-role&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  assume_role_policy</span> <span class="o">=</span> <span class="k">jsonencode</span><span class="p">(</span>{
</span></span><span class="line"><span class="cl"><span class="n">    Version</span> <span class="o">=</span> <span class="s2">&#34;2012-10-17&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">    Statement</span> <span class="o">=</span> <span class="p">[</span>{
</span></span><span class="line"><span class="cl"><span class="n">      Action</span> <span class="o">=</span> <span class="s2">&#34;sts:AssumeRole&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">      Principal</span> <span class="o">=</span> {
</span></span><span class="line"><span class="cl"><span class="n">        Service</span> <span class="o">=</span> <span class="s2">&#34;ecs-tasks.amazonaws.com&#34;</span>
</span></span><span class="line"><span class="cl">      }<span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">      Effect</span> <span class="o">=</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    }<span class="p">]</span>
</span></span><span class="line"><span class="cl">  }<span class="p">)</span>
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">resource</span> <span class="s2">&#34;aws_iam_role_policy_attachment&#34; &#34;execution&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  role</span>       <span class="o">=</span> <span class="k">aws_iam_role</span><span class="p">.</span><span class="k">execution</span><span class="p">.</span><span class="k">name</span>
</span></span><span class="line"><span class="cl"><span class="n">  policy_arn</span> <span class="o">=</span> <span class="s2">&#34;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy&#34;</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## ECS 위에서 띄울 태스크에 대한 정의입니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_ecs_task_definition&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  family</span>                   <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">app_name</span>
</span></span><span class="line"><span class="cl"><span class="n">  network_mode</span>             <span class="o">=</span> <span class="s2">&#34;awsvpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  requires_compatibilities</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;FARGATE&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  cpu</span>                      <span class="o">=</span> <span class="m">256</span><span class="c1"> # CPU, 메모리는 가장 작은 값을 사용합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">  memory</span>                   <span class="o">=</span> <span class="m">512</span>
</span></span><span class="line"><span class="cl"><span class="n">  execution_role_arn</span>       <span class="o">=</span> <span class="k">aws_iam_role</span><span class="p">.</span><span class="k">execution</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">  container_definitions</span> <span class="o">=</span> <span class="k">jsonencode</span><span class="p">([</span>{
</span></span><span class="line"><span class="cl"><span class="n">    name</span>  <span class="o">=</span> <span class="s2">&#34;app&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">    image</span> <span class="o">=</span> <span class="s2">&#34;${aws_ecr_repository.simon_sample.repository_url}:latest&#34;</span><span class="p">,</span><span class="c1"> # ECR에 올라온 이미지를 사용합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">    cpu</span>   <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="n">    portMappings</span> <span class="o">=</span> <span class="p">[</span>{<span class="c1"> # 3000번 포트를 외부에 엽니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">      hostPort</span>      <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl"><span class="n">      protocol</span>      <span class="o">=</span> <span class="s2">&#34;tcp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">      containerPort</span> <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl">    }<span class="p">]</span>
</span></span><span class="line"><span class="cl">  }<span class="p">])</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>이제 컨테이너를 띄울 준비가 끝났습니다. 서비스를 정의하면 설정된 것에 맞춰 작업(태스크)가 뜹니다</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="c1">## ECR에서 데이터를 가져오려면 태스크에 인터넷에 접근할 수 있는 권한을 주어야 합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_security_group&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span>   <span class="o">=</span> <span class="s2">&#34;${local.app_name}-sg&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">  <span class="k">egress</span> {
</span></span><span class="line"><span class="cl"><span class="n">    from_port</span>   <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="n">    to_port</span>     <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="n">    protocol</span>    <span class="o">=</span> <span class="s2">&#34;-1&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">    cidr_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;0.0.0.0/0&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## ECS 서비스를 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_ecs_service&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  desired_count</span>   <span class="o">=</span> <span class="m">1</span><span class="c1"> # 태스크를 하나만 띄웁니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">  name</span>            <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">app_name</span>
</span></span><span class="line"><span class="cl"><span class="n">  cluster</span>         <span class="o">=</span> <span class="k">aws_ecs_cluster</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">  task_definition</span> <span class="o">=</span> <span class="k">aws_ecs_task_definition</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">  launch_type</span>     <span class="o">=</span> <span class="s2">&#34;FARGATE&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="k">network_configuration</span> {
</span></span><span class="line"><span class="cl"><span class="n">    subnets</span>         <span class="o">=</span> <span class="k">aws_subnet</span><span class="p">.</span><span class="k">private</span><span class="p">[</span><span class="err">*</span><span class="p">].</span><span class="k">id</span><span class="c1"> # 프라이빗 서브넷에 배치합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">    security_groups</span> <span class="o">=</span> <span class="p">[</span><span class="k">aws_security_group</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="서비스를-외부에-노출하기">서비스를 외부에 노출하기</h2>
<p>이렇게 만들어진 서비스는 외부에서 접속이 불가능하기 때문에 사실 아무 쓸모가 없습니다. (로그도 없어서 잘 떴는지 확인하기도 어렵습니다.)</p>
<p>ECS 태스크를 직접 외부에 노출할 수도 있겠지만, 보통 여러개의 태스크를 실행하기 때문에 앞에 트래픽을 분산해주는 서버가 필요합니다. 이는 로드 밸런서를 이용해 달성할 수 있습니다. 이 로드 밸런서를 퍼블릭 서브넷에 배치함으로써 외부에서 트래픽도 받을 수 있습니다.</p>
<p>3000번 포트로 트래픽을 전송하는 로드밸런서 타겟 그룹을 만들어 로드 밸런서 80포트(HTTP)로 트래픽이 들어오면 전송하도록 설정합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="k">locals</span> {
</span></span><span class="line"><span class="cl"><span class="n">  lb_name</span> <span class="o">=</span> <span class="s2">&#34;simon-test-lb&#34;</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 외부에 80번 포트를 여는 보안 그룹을 생성합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_security_group&#34; &#34;lb&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span>   <span class="o">=</span> <span class="s2">&#34;${local.lb_name}-sg&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span> <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">  <span class="k">ingress</span> {
</span></span><span class="line"><span class="cl"><span class="n">    from_port</span>   <span class="o">=</span> <span class="m">80</span>
</span></span><span class="line"><span class="cl"><span class="n">    to_port</span>     <span class="o">=</span> <span class="m">80</span>
</span></span><span class="line"><span class="cl"><span class="n">    protocol</span>    <span class="o">=</span> <span class="s2">&#34;tcp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">    cidr_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;0.0.0.0/0&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## HTTP 요청을 분산하는 어플리케이션 로드 밸런서를 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_lb&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span>               <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">lb_name</span>
</span></span><span class="line"><span class="cl"><span class="n">  internal</span>           <span class="o">=</span> <span class="kt">false</span>
</span></span><span class="line"><span class="cl"><span class="n">  load_balancer_type</span> <span class="o">=</span> <span class="s2">&#34;application&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  security_groups</span>    <span class="o">=</span> <span class="p">[</span><span class="k">aws_security_group</span><span class="p">.</span><span class="k">lb</span><span class="p">.</span><span class="k">id</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">  subnets</span>            <span class="o">=</span> <span class="k">aws_subnet</span><span class="p">.</span><span class="k">public</span><span class="p">[</span><span class="err">*</span><span class="p">].</span><span class="k">id</span><span class="c1"> # 퍼블릭 서브넷에 배치합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## 로드 밸런서로 온 요청을 받아 처리할 목표 그룹을 정의합니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_lb_target_group&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  name</span>        <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">app_name</span>
</span></span><span class="line"><span class="cl"><span class="n">  port</span>        <span class="o">=</span> <span class="m">3000</span><span class="c1"> # 우리가 만든 컨테이너는 3000번 포트에서 입력을 받습니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">  protocol</span>    <span class="o">=</span> <span class="s2">&#34;HTTP&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  target_type</span> <span class="o">=</span> <span class="s2">&#34;ip&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  vpc_id</span>      <span class="o">=</span> <span class="k">aws_vpc</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">## HTTP(80)에 대한 리스너를 생성합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_lb_listener&#34; &#34;http&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  load_balancer_arn</span> <span class="o">=</span> <span class="k">aws_lb</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">  port</span>              <span class="o">=</span> <span class="s2">&#34;80&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  protocol</span>          <span class="o">=</span> <span class="s2">&#34;HTTP&#34;</span><span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">  # 앞서 정의한 타겟 그룹으로 모든 트래픽을 보냅니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">default_action</span> {
</span></span><span class="line"><span class="cl"><span class="n">    type</span>             <span class="o">=</span> <span class="s2">&#34;forward&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">    target_group_arn</span> <span class="o">=</span> <span class="k">aws_lb_target_group</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>이렇게 생성된 로드 밸런서는 <code>simon-test-lb-135798642.ap-northeast-2.elb.amazonaws.com</code>와 같은 주소를 할당받게 됩니다. 아직 이전에 만든 ECS 태스크가 타겟 그룹에 등록되지 않았기 때문에, 이 주소에 접속해보면 503 에러가 발생합니다. 두가지 추가 작업이 필요합니다.</p>
<p>우선 ECS 태스크가 3000번 포트에서의 입력을 처리할 수 있도록 해야 합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="c1">## ECS는 로드 밸런서에서 3000번 포트로 온 요청을 받을 수 있습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_security_group_rule&#34; &#34;ecs_from_lb&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  security_group_id</span>        <span class="o">=</span> <span class="k">aws_security_group</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  type</span>                     <span class="o">=</span> <span class="s2">&#34;ingress&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  from_port</span>                <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl"><span class="n">  to_port</span>                  <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl"><span class="n">  protocol</span>                 <span class="o">=</span> <span class="s2">&#34;tcp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  source_security_group_id</span> <span class="o">=</span> <span class="k">aws_security_group</span><span class="p">.</span><span class="k">lb</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>또 로드 밸런서에서 ECS 태스크로 요청도 가능해야 합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="c1">## 로드 밸런서에서 ECS의 3000번 포트로 요청을 보낼 수 있습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">resource</span> <span class="s2">&#34;aws_security_group_rule&#34; &#34;lb_to_ecs&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  security_group_id</span>        <span class="o">=</span> <span class="k">aws_security_group</span><span class="p">.</span><span class="k">lb</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">  type</span>                     <span class="o">=</span> <span class="s2">&#34;egress&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  from_port</span>                <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl"><span class="n">  to_port</span>                  <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl"><span class="n">  protocol</span>                 <span class="o">=</span> <span class="s2">&#34;tcp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">  source_security_group_id</span> <span class="o">=</span> <span class="k">aws_security_group</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>다음으로는 ECS 서비스 정의를 변경해 태스크가 만들어지면 타겟 그룹에 등록하게 하게 하면 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hcl" data-lang="hcl"><span class="line"><span class="cl"><span class="k">resource</span> <span class="s2">&#34;aws_ecs_service&#34; &#34;this&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  desired_count</span>   <span class="o">=</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="n">  name</span>            <span class="o">=</span> <span class="k">local</span><span class="p">.</span><span class="k">app_name</span>
</span></span><span class="line"><span class="cl"><span class="n">  cluster</span>         <span class="o">=</span> <span class="k">aws_ecs_cluster</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">  task_definition</span> <span class="o">=</span> <span class="k">aws_ecs_task_definition</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">  launch_type</span>     <span class="o">=</span> <span class="s2">&#34;FARGATE&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="k">network_configuration</span> {
</span></span><span class="line"><span class="cl"><span class="n">    subnets</span>         <span class="o">=</span> <span class="k">aws_subnet</span><span class="p">.</span><span class="k">private</span><span class="p">[</span><span class="err">*</span><span class="p">].</span><span class="k">id</span>
</span></span><span class="line"><span class="cl"><span class="n">    security_groups</span> <span class="o">=</span> <span class="p">[</span><span class="k">aws_security_group</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">id</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  }<span class="c1">
</span></span></span><span class="line"><span class="cl"><span class="c1">  # 다음을 추가합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">load_balancer</span> {
</span></span><span class="line"><span class="cl"><span class="n">    target_group_arn</span> <span class="o">=</span> <span class="k">aws_lb_target_group</span><span class="p">.</span><span class="k">this</span><span class="p">.</span><span class="k">arn</span>
</span></span><span class="line"><span class="cl"><span class="n">    container_name</span>   <span class="o">=</span> <span class="s2">&#34;app&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">    container_port</span>   <span class="o">=</span> <span class="m">3000</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>이제 로드 밸런서 주소로 요청을 보내면 로컬과 마찬가지로 응답을 보내옵니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl simon-test-lb-135798642.ap-northeast-2.elb.amazonaws.com --data <span class="s1">&#39;hello world&#39;</span>
</span></span><span class="line"><span class="cl">hello world
</span></span></code></pre></div><h2 id="남은-작업">남은 작업</h2>
<p>실제 서비스에 더 가까우려면 추가로 해줘야 할 것들이 많이 있습니다. 다만 이번글에서는 따로 설명하지 않겠습니다.</p>
<ul>
<li>로드 밸런서 주소는 랜덤하게 생성됩니다. 이를 실제 서비스에서 쓰기는 어렵고 서비스만의 도메인을 설정해주는게 좋습니다. Route53에 별칭 A 레코드를 생성하면 됩니다.</li>
<li>여기서는 HTTP 트래픽을 받고 있지만, 안전한 통신을 위해 HTTPS를 사용하면 좋습니다. AWS Certificate Manager로 인증서를 생성해 로드 밸런서에 설정하면 로드 밸런서에서 TLS 종료를 처리해줍니다. 그 뒷단에 있는 우리의 어플리케이션에서는 HTTP만 처리하면 됩니다.</li>
<li>현재 트래픽을 받을 수 있는 서버가 하나 뿐입니다. 서버만 늘리면 로드 밸런서가 알아서 트래픽을 분산해줍니다. desired_count를 조절해 수동으로 서버를 늘릴 수도 있고, 오토 스케일링 정책을 설정해 트래픽에 따라 서버를 늘이고 줄일 수도 있습니다.</li>
<li>현재는 컨테이너에서 발생한 로그를 볼 수 없습니다. CloudWatch Logs를 연결해 로그를 기록할 수 있습니다.</li>
<li>CloudFront를 연결하면 전세계에서 접근할 때 지연 시간을 줄이는 등 추가 이득을 얻을 수 있습니다.</li>
</ul>
<h2 id="appendix">Appendix</h2>
<ul>
<li>예제 파일: <a href="/file/2022-03-31-1-simon-sample.zip">simon-sample.zip</a>
<blockquote>
<p>전체 Terraform 파일에서 한번에 스택을 생성할 때는 먼저 ECR만 생성해(<code>terraform apply --target aws_ecr_repository.simon_sample</code>) 이미지를 올린 후 나머지를 생성해주는게 깔끔합니다.</p></blockquote>
</li>
<li><a href="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Scenario2.html">퍼블릭 및 프라이빗 서브넷이 있는 VPC(NAT)</a></li>
<li><a href="https://docs.aws.amazon.com/ko_kr/ecs/index.html">Amazon Elastic Container Service 설명서</a></li>
<li><a href="https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html">ELB 로드 밸런서로 트래픽 라우팅</a></li>
<li><a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/application/create-https-listener.html">Application Load Balancer용 HTTPS 리스너 생성</a></li>
</ul>
      
      <hr>
      <div class='post-original'>
        원본 링크 : <a href='http://sixmen.com/ko/tech/2022-03-31-1-web-application-using-ecs/' target='_blank'>http://sixmen.com/ko/tech/2022-03-31-1-web-application-using-ecs/</a>
      </div>
      
    </div>

    <div class='col-lg-3 sidemenu'>
  <h4>Recent Posts</h4>
  <ul class="sidemenu-recent-list">
    
    <a href='/ko/2024-10-07-1-animation-module/'>
      <li class="sidemenu-recent-item">기획전 애니메이션 모듈 개발</li>
    </a>
    
    <a href='/ko/2024-08-09-1-ui-testing-automation/'>
      <li class="sidemenu-recent-item">UI 테스트 자동화</li>
    </a>
    
    <a href='/ko/2024-08-04-1-improve-server-driven-ui/'>
      <li class="sidemenu-recent-item">Server Driven UI 호출 구조 개선</li>
    </a>
    
    <a href='/ko/2024-06-28-1-optimize-font-traffic/'>
      <li class="sidemenu-recent-item">웹폰트 최적화를 통한 CDN 비용절감</li>
    </a>
    
  </ul>
  <hr>
  <h4>Tags</h4>
  <ul class="sidemenu-recent-list">
    
    <a href="/ko/tags/amazon-sqs/">
      <li class="sidemenu-recent-tags">amazon sqs</li>
    </a>
    
    <a href="/ko/tags/analytics/">
      <li class="sidemenu-recent-tags">analytics</li>
    </a>
    
    <a href="/ko/tags/android/">
      <li class="sidemenu-recent-tags">android</li>
    </a>
    
    <a href="/ko/tags/aws/">
      <li class="sidemenu-recent-tags">aws</li>
    </a>
    
    <a href="/ko/tags/aws-batch/">
      <li class="sidemenu-recent-tags">aws batch</li>
    </a>
    
    <a href="/ko/tags/aws-lambda/">
      <li class="sidemenu-recent-tags">aws lambda</li>
    </a>
    
    <a href="/ko/tags/botkit/">
      <li class="sidemenu-recent-tags">botkit</li>
    </a>
    
    <a href="/ko/tags/croquis/">
      <li class="sidemenu-recent-tags">croquis</li>
    </a>
    
    <a href="/ko/tags/css/">
      <li class="sidemenu-recent-tags">css</li>
    </a>
    
    <a href="/ko/tags/data/">
      <li class="sidemenu-recent-tags">data</li>
    </a>
    
    <a href="/ko/tags/event/">
      <li class="sidemenu-recent-tags">event</li>
    </a>
    
    <a href="/ko/tags/front-end/">
      <li class="sidemenu-recent-tags">front-end</li>
    </a>
    
    <a href="/ko/tags/frontend/">
      <li class="sidemenu-recent-tags">frontend</li>
    </a>
    
    <a href="/ko/tags/git/">
      <li class="sidemenu-recent-tags">git</li>
    </a>
    
    <a href="/ko/tags/github/">
      <li class="sidemenu-recent-tags">github</li>
    </a>
    
    <a href="/ko/tags/graphql/">
      <li class="sidemenu-recent-tags">graphql</li>
    </a>
    
    <a href="/ko/tags/ios/">
      <li class="sidemenu-recent-tags">ios</li>
    </a>
    
    <a href="/ko/tags/jenkins/">
      <li class="sidemenu-recent-tags">jenkins</li>
    </a>
    
    <a href="/ko/tags/jotai/">
      <li class="sidemenu-recent-tags">jotai</li>
    </a>
    
    <a href="/ko/tags/kubernetes/">
      <li class="sidemenu-recent-tags">kubernetes</li>
    </a>
    
    <a href="/ko/tags/log/">
      <li class="sidemenu-recent-tags">log</li>
    </a>
    
    <a href="/ko/tags/microservice/">
      <li class="sidemenu-recent-tags">microservice</li>
    </a>
    
    <a href="/ko/tags/mithril/">
      <li class="sidemenu-recent-tags">mithril</li>
    </a>
    
    <a href="/ko/tags/node.js/">
      <li class="sidemenu-recent-tags">node.js</li>
    </a>
    
    <a href="/ko/tags/nodejs/">
      <li class="sidemenu-recent-tags">nodejs</li>
    </a>
    
    <a href="/ko/tags/npm/">
      <li class="sidemenu-recent-tags">npm</li>
    </a>
    
    <a href="/ko/tags/react/">
      <li class="sidemenu-recent-tags">react</li>
    </a>
    
    <a href="/ko/tags/rest-api/">
      <li class="sidemenu-recent-tags">rest api</li>
    </a>
    
    <a href="/ko/tags/serverless-architecture/">
      <li class="sidemenu-recent-tags">serverless architecture</li>
    </a>
    
    <a href="/ko/tags/slack/">
      <li class="sidemenu-recent-tags">slack</li>
    </a>
    
    <a href="/ko/tags/stack/">
      <li class="sidemenu-recent-tags">stack</li>
    </a>
    
    <a href="/ko/tags/storybook/">
      <li class="sidemenu-recent-tags">storybook</li>
    </a>
    
    <a href="/ko/tags/task-queue/">
      <li class="sidemenu-recent-tags">task queue</li>
    </a>
    
    <a href="/ko/tags/testing/">
      <li class="sidemenu-recent-tags">testing</li>
    </a>
    
    <a href="/ko/tags/thrift/">
      <li class="sidemenu-recent-tags">thrift</li>
    </a>
    
    <a href="/ko/tags/tutorial/">
      <li class="sidemenu-recent-tags">tutorial</li>
    </a>
    
    <a href="/ko/tags/typescript/">
      <li class="sidemenu-recent-tags">typescript</li>
    </a>
    
    <a href="/ko/tags/ui/">
      <li class="sidemenu-recent-tags">ui</li>
    </a>
    
    <a href="/ko/tags/vertical-align/">
      <li class="sidemenu-recent-tags">vertical-align</li>
    </a>
    
    <a href="/ko/tags/webpack/">
      <li class="sidemenu-recent-tags">webpack</li>
    </a>
    
    <a href="/ko/tags/%EB%A1%9C%EA%B7%B8/">
      <li class="sidemenu-recent-tags">로그</li>
    </a>
    
    <a href="/ko/tags/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4/">
      <li class="sidemenu-recent-tags">마이크로서비스</li>
    </a>
    
    <a href="/ko/tags/%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/">
      <li class="sidemenu-recent-tags">튜토리얼</li>
    </a>
    
  </ul>
</div>

    <div class='col-12'>
      <hr>

      <div class='float-left'>
        
        <a class='btn btn-outline-primary' href='/ko/2022-03-07-1-npm-private-repository/' title='사내 npm 패키지 저장소를 구축하기 위해 겪었던 과정들'>&larr; 이전 글</a>
        
      </div>
      <div class='float-right'>
        
        <a class='btn btn-outline-primary' href='/ko/2022-03-31-2-web-application-using-eks/' title='EKS를 사용해서 어플리케이션 서비스 하기'>다음 글 &rarr;</a>
        
      </div>
      <div class='clearfix'></div>
      <hr>
      <div class='text-center'>
        <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "croquiscom-devblog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
  </div>

</div>

<div class='container'>
  <hr>
  <footer>
    <p>
      &copy; 2012-2021 kakaostyle.com
      <span class='float-right text-muted'>
        powered by
        <a href='https://gohugo.io/' target='_blank'>Hugo</a>
        and
        <a href='https://getbootstrap.com/' target='_blank'>Bootstrap</a>
      </span>
    </p>
  </footer>
</div>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-HBL5QKGKNR"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-HBL5QKGKNR');
        }
      </script>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
  integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"
  integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"
  integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
<script src="https://use.fontawesome.com/releases/v5.0.13/js/all.js"
  integrity="sha384-xymdQtn1n3lH2wcu0qhcdaOpQwyoarkgLVxC/wZ5q7h9gHtxICrpcaSUfygqZGOe" crossorigin="anonymous"></script>

</body>

</html>
